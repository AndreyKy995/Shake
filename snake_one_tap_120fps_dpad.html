<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>–ó–º–µ–π–∫–∞ ‚Äî One‚ÄëTap + –°—Ç—Ä–µ–ª–æ—á–∫–∏ (120FPS)</title>
  <style>
    :root{
      --ui:#0b132b;
      --accent:#ff6b6b;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:#a7e5ff;font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial}
    #wrap{position:fixed;inset:0;display:flex;flex-direction:column}
    header{display:flex;align-items:center;justify-content:space-between;padding:10px 14px;color:#122}
    header .score{font-weight:800;font-size:18px;text-shadow:0 1px 0 rgba(255,255,255,.6)}
    header .btn{appearance:none;border:0;background:var(--ui);color:#fff;border-radius:14px;padding:8px 12px;font-weight:700;box-shadow:0 4px 0 rgba(0,0,0,.15);transform:translateY(0);transition:.05s}
    header .btn:active{transform:translateY(2px);box-shadow:0 2px 0 rgba(0,0,0,.15)}

    #game{position:relative;flex:1;overflow:hidden}
    canvas{width:100%;height:100%;display:block;touch-action:none}

    #hint{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);text-align:center;color:#123;font-weight:800;background:rgba(255,255,255,.85);padding:14px 16px;border-radius:18px;backdrop-filter:blur(4px);box-shadow:0 10px 30px rgba(0,0,0,.15)}
    #hint h1{margin:.2em 0;font-size:24px}
    #hint p{margin:.35em 0;font-size:14px;opacity:.8}
    #hint .big{font-size:16px}

    #tapBtn{position:absolute;right:14px;bottom:14px;width:86px;height:86px;border-radius:50%;background:radial-gradient(circle at 35% 30%, #fff, #eaeaea);box-shadow:inset 0 -8px 16px rgba(0,0,0,.15), 0 12px 24px rgba(0,0,0,.20);display:flex;align-items:center;justify-content:center;font-weight:900;color:#333;user-select:none}
    #tapBtn::after{content:"‚Üª";font-size:36px;}

    /* D-Pad for phone */
    #dpad{position:absolute;left:14px;bottom:14px;width:min(38vw,210px);height:min(38vw,210px);display:grid;grid-template-columns:1fr 1fr 1fr;grid-template-rows:1fr 1fr 1fr;gap:10px;touch-action:none;user-select:none}
    #dpad .btn{background:radial-gradient(circle at 35% 30%, #fff, #eaeaea);box-shadow:inset 0 -8px 16px rgba(0,0,0,.15), 0 12px 24px rgba(0,0,0,.20);border-radius:18px;display:flex;align-items:center;justify-content:center;font-weight:900;color:#333;font-size:28px}
    #dpad .btn:active{transform:translateY(2px);box-shadow:inset 0 -6px 12px rgba(0,0,0,.2), 0 8px 16px rgba(0,0,0,.20)}
    #dpad .blank{opacity:0;pointer-events:none}

    #toast{position:absolute;left:50%;bottom:14px;transform:translateX(-50%);background:rgba(0,0,0,.75);color:#fff;padding:8px 12px;border-radius:12px;font-size:12px;opacity:0;transition:.3s;pointer-events:none}
    #toast.show{opacity:1}
  </style>
</head>
<body>
  <div id="wrap">
    <header>
      <div class="score">–û—á–∫–∏: <span id="score">0</span> ¬∑ –†–µ–∫–æ—Ä–¥: <span id="best">0</span> ¬∑ 120 FPS</div>
      <div>
        <button id="pause" class="btn">–ü–∞—É–∑–∞</button>
        <button id="restart" class="btn" style="margin-left:8px">–ó–∞–Ω–æ–≤–æ</button>
      </div>
    </header>
    <div id="game">
      <canvas id="c"></canvas>
      <div id="hint">
        <h1>–ó–º–µ–π–∫–∞ 120FPS ‚Äî —Ç–∞–ø ‚Üª –∏ —Å—Ç—Ä–µ–ª–æ—á–∫–∏ ‚¨ÜÔ∏è‚¨áÔ∏è‚¨ÖÔ∏è‚û°Ô∏è</h1>
        <p class="big">–¢–∞–ø ‚Äî –ø–æ–≤–æ—Ä–æ—Ç –ø–æ —á–∞—Å–æ–≤–æ–π. –°—Ç—Ä–µ–ª–æ—á–∫–∏ ‚Äî —Ç–æ—á–Ω–æ–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ (–±–µ–∑ —Ä–∞–∑–≤–æ—Ä–æ—Ç–∞ –Ω–∞ 180¬∞).</p>
        <p>–ü–ª–∞–≤–Ω–∞—è –∞–Ω–∏–º–∞—Ü–∏—è, –ø–∞—Ä—Ç–∏–∫–ª—ã, —Ç–µ–Ω–∏, –¥–µ–Ω—å/–Ω–æ—á—å. –¢–∞–ø–Ω–∏, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å.</p>
      </div>
      <div id="tapBtn" aria-label="–ü–æ–≤–µ—Ä–Ω—É—Ç—å –ø–æ —á–∞—Å–æ–≤–æ–π"></div>

      <!-- On-screen D-Pad -->
      <div id="dpad" aria-label="–ö—Ä–µ—Å—Ç–æ–≤–∏–Ω–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è">
        <div class="btn blank"></div>
        <div class="btn" id="up">‚¨ÜÔ∏è</div>
        <div class="btn blank"></div>
        <div class="btn" id="left">‚¨ÖÔ∏è</div>
        <div class="btn blank"></div>
        <div class="btn" id="right">‚û°Ô∏è</div>
        <div class="btn blank"></div>
        <div class="btn" id="down">‚¨áÔ∏è</div>
        <div class="btn blank"></div>
      </div>

      <div id="toast"></div>
    </div>
  </div>

  <script>
  const cfg = {
    baseSpeed: 6.8,
    speedPerApple: 0.28,
    cell: 26,
    gridMargin: 1,
    startLen: 6,
    maxFPS: 120,
    wiggleAmp: 0.18,
    wiggleFreq: 6,
    particleCount: 16,
    dayNightPeriod: 35,
  };

  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const bestEl = document.getElementById('best');
  const pauseBtn = document.getElementById('pause');
  const restartBtn = document.getElementById('restart');
  const hint = document.getElementById('hint');
  const tapBtn = document.getElementById('tapBtn');
  const toast = document.getElementById('toast');

  const upBtn = document.getElementById('up');
  const downBtn = document.getElementById('down');
  const leftBtn = document.getElementById('left');
  const rightBtn = document.getElementById('right');

  let DPR = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
  let gridW = 24, gridH = 36;
  let cell;

  let lastTime = 0, acc = 0, stepTime = 0;
  const DIR = {R:0,D:1,L:2,U:3};
  const turnCW = d => (d+1) & 3;
  const vec = d => d===DIR.R?[1,0]:d===DIR.D?[0,1]:d===DIR.L?[-1,0]:[0,-1];
  const lerp = (a,b,t)=>a+(b-a)*t;
  const opposite = (a,b)=> (a^2)===b; // 0<->2, 1<->3

  let actx;
  function beep(type='eat'){
    if(!actx) return;
    const o = actx.createOscillator();
    const g = actx.createGain();
    o.connect(g); g.connect(actx.destination);
    let f = 440, t = 0.08, typeWave='triangle';
    if(type==='eat'){ f=640+Math.random()*60; t=0.12; typeWave='sine'; }
    if(type==='turn'){ f=520+Math.random()*30; t=0.05; typeWave='triangle'; }
    if(type==='hit'){ f=90; t=0.35; typeWave='square'; }
    o.type = typeWave;
    o.frequency.setValueAtTime(f, actx.currentTime);
    g.gain.setValueAtTime(0.001, actx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.15, actx.currentTime+0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, actx.currentTime+t);
    o.start(); o.stop(actx.currentTime + t + 0.02);
  }

  let state;
  let prevSnake = [];
  let particles = [];
  let shakeT = 0;
  let desiredDir = null; // –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ, –≤—ã–±—Ä–∞–Ω–Ω–æ–µ —Å—Ç—Ä–µ–ª–∫–∞–º–∏

  function reset(){
    const w = canvas.clientWidth, h = canvas.clientHeight;
    cell = Math.max(18, Math.min(cfg.cell, Math.floor(Math.min(w,h)/(isPortrait()?22:18))));
    gridW = Math.floor(w / cell) - cfg.gridMargin*2;
    gridH = Math.floor((h / cell)) - cfg.gridMargin*2;
    gridW = Math.max(14, gridW);
    gridH = Math.max(18, gridH);

    canvas.width = Math.floor((gridW + cfg.gridMargin*2) * cell * DPR);
    canvas.height = Math.floor((gridH + cfg.gridMargin*2) * cell * DPR);

    state = {
      snake: [],
      dir: DIR.R,
      speed: cfg.baseSpeed,
      alive: true,
      started: false,
      score: 0,
      best: Number(localStorage.getItem('snake_best_120_dpad')||0),
      apple: null,
      t: 0,
    };
    particles.length = 0;
    shakeT = 0;
    desiredDir = null;

    const cx = Math.floor(gridW/3), cy = Math.floor(gridH/2);
    for(let i=cfg.startLen-1;i>=0;i--) state.snake.push({x:cx-i,y:cy});
    prevSnake = state.snake.map(s=>({x:s.x,y:s.y}));
    placeApple();
    scoreEl.textContent = state.score;
    bestEl.textContent = state.best;
    stepTime = 1/state.speed;
    acc = 0; lastTime = 0;
    draw(0,true);
  }

  function isPortrait(){ return window.innerHeight >= window.innerWidth; }
  function randFreeCell(){ return {x: Math.floor(Math.random()*gridW), y: Math.floor(Math.random()*gridH)}; }
  function placeApple(){
    let tries=0;
    while(tries++<999){
      const a = randFreeCell();
      if(!state.snake.some(s=>s.x===a.x && s.y===a.y)){ state.apple = a; return; }
    }
    state.apple = randFreeCell();
  }
  function spawnParticles(x,y){
    for(let i=0;i<cfg.particleCount;i++){
      const ang = Math.random()*Math.PI*2;
      const spd = 2 + Math.random()*5;
      particles.push({x,y, vx:Math.cos(ang)*spd, vy:Math.sin(ang)*spd, life:0.6+Math.random()*0.4});
    }
  }

  function stepLogic(){
    // –ü—Ä–∏–º–µ–Ω—è–µ–º –∂–µ–ª–∞–µ–º–æ–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ (–µ—Å–ª–∏ –Ω–µ –ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω–æ–µ —Ç–µ–∫—É—â–µ–º—É)
    if(desiredDir!==null && !opposite(state.dir, desiredDir)){
      state.dir = desiredDir;
      desiredDir = null;
    }

    prevSnake = state.snake.map(s=>({x:s.x,y:s.y}));
    const [vx,vy] = vec(state.dir);
    const head = {x: state.snake[0].x + vx, y: state.snake[0].y + vy};

    if(head.x<0 || head.y<0 || head.x>=gridW || head.y>=gridH){ die(); return; }
    for(let i=0;i<state.snake.length;i++){
      if(state.snake[i].x===head.x && state.snake[i].y===head.y){ die(); return; }
    }

    state.snake.unshift(head);

    if(head.x===state.apple.x && head.y===state.apple.y){
      state.score++; scoreEl.textContent = state.score;
      beep('eat'); spawnParticles(head.x+0.5, head.y+0.5);
      state.speed += cfg.speedPerApple; stepTime = 1/state.speed;
      placeApple(); toastMsg('+1'); shakeT = 0.18;
    }else{
      state.snake.pop();
    }
  }

  function die(){
    state.alive = false;
    beep('hit'); toastMsg('üí• –¢—ã –≤—Ä–µ–∑–∞–ª—Å—è! –¢–∞–ø–Ω–∏, —á—Ç–æ–±—ã —Å—ã–≥—Ä–∞—Ç—å –µ—â—ë.');
    if(state.score>state.best){
      state.best = state.score; localStorage.setItem('snake_best_120_dpad',state.best);
      bestEl.textContent = state.best; toastMsg('üèÜ –ù–æ–≤—ã–π —Ä–µ–∫–æ—Ä–¥: '+state.best);
    }
    hint.style.display = 'block'; shakeT = 0.35;
  }

  function update(dt){
    if(!state.started || !state.alive) return;
    acc += dt; state.t += dt;
    const maxSteps = 4; let steps=0;
    while(acc >= stepTime && steps++<maxSteps){ stepLogic(); acc -= stepTime; }

    for(let i=particles.length-1;i>=0;i--){
      const p = particles[i]; p.life -= dt; p.x += p.vx*dt; p.y += p.vy*dt; p.vy += 2.5*dt;
      if(p.life<=0) particles.splice(i,1);
    }
    if(shakeT>0){ shakeT = Math.max(0, shakeT - dt); }
  }

  function draw(ts){
    const cw = canvas.width, ch = canvas.height;
    const u = cell * DPR;
    const ox = cfg.gridMargin * u, oy = cfg.gridMargin * u;

    const dayT = (Math.sin(state.t * (Math.PI*2/cfg.dayNightPeriod)) + 1)/2;
    const skyTop = mixColor([167,229,255], [20,25,60], 1-dayT);
    const skyBot = mixColor([232,255,246], [35,45,85], 1-dayT);
    const grd = ctx.createLinearGradient(0,0,0,ch);
    grd.addColorStop(0, rgb(skyTop));
    grd.addColorStop(1, rgb(skyBot));
    ctx.fillStyle = grd; ctx.fillRect(0,0,cw,ch);

    if(dayT<0.35){
      const n = 80; ctx.fillStyle = 'rgba(255,255,255,0.8)';
      for(let i=0;i<n;i++){ const x = (i*12347 % cw); const y = (i*8123 % (ch*0.5));
        ctx.globalAlpha = (((i*37)+Math.floor(state.t*60))%5===0)?0.5:1;
        ctx.fillRect((x+ (i*13)%7), (y+ (i*19)%5), 2,2);
      }
      ctx.globalAlpha = 1;
    }
    if(dayT>0.25){
      cloud(((state.t*120)% (cw+200))-100, 0.18*ch, 1.2, 0.85);
      cloud(((((state.t*80)+300)%(cw+300))-150), 0.28*ch, 0.95, 0.75);
    }
    ctx.fillStyle = '#b8e986'; ctx.fillRect(0, ch-0.22*ch, cw, 0.22*ch);

    ctx.save();
    const shx = (Math.random()*2-1)*8*shakeT*DPR;
    const shy = (Math.random()*2-1)*8*shakeT*DPR;
    ctx.translate(shx, shy);

    ctx.save(); ctx.translate(ox, oy);
    const gw = gridW*u, gh = gridH*u;
    rounded( -16, -16, gw+32, gh+32, 24, 'rgba(0,0,0,0.05)' );
    rounded( 0, 0, gw, gh, 20, null, gradient(ctx, 0,0, gw,gh, ['#d9ffd2','#c9ffb8']) );

    if(state.apple){
      const ax = (state.apple.x + 0.5)*u; const ay = (state.apple.y + 0.5)*u;
      ctx.save(); ctx.translate(ax, ay); const r = u*0.38;
      ctx.fillStyle = 'rgba(0,0,0,0.18)'; ellipse(4, r*0.9, r*0.9*0.5, r*0.24, true);
      const appleGrad = ctx.createRadialGradient(-r*0.2,-r*0.2, r*0.2, 0,0, r);
      appleGrad.addColorStop(0,'#ff8a8a'); appleGrad.addColorStop(1,'#ff4d4d'); ctx.fillStyle = appleGrad;
      ellipse(0,0,r,r*0.82,true);
      ctx.fillStyle = '#2ecc71'; ellipse(r*0.1,-r*0.9,r*0.22,r*0.12,true);
      ctx.fillStyle = 'rgba(255,255,255,.8)'; ellipse(-r*0.2,-r*0.1,r*0.18,r*0.10,true);
      ctx.restore();
    }

    const it = Math.min(1, acc/stepTime || 0);
    const renderPts = []; const N = state.snake.length;
    for(let i=0;i<N;i++){
      const cur = state.snake[i], prev = prevSnake[i] || state.snake[i];
      renderPts.push({ x: lerp(prev.x, cur.x, it), y: lerp(prev.y, cur.y, it) });
    }
    if(renderPts.length){
      const head = renderPts[0];
      const d = state.dir; const v = vec(d); const ortho = {x:-v[1], y:v[0]};
      const amp = cfg.wiggleAmp * Math.sin(state.t*cfg.wiggleFreq*2*Math.PI);
      head.x += ortho.x * amp; head.y += ortho.y * amp;
    }
    drawRibbon(renderPts, u*0.74, u);

    if(renderPts.length){
      const h = renderPts[0]; const hx = h.x*u, hy = h.y*u; const r = u*0.38;
      ctx.fillStyle = '#fff'; const d = state.dir; const v = vec(d);
      ellipse(hx + (v[0]?0: -r*0.22), hy - (v[1]?0: r*0.18), r*0.18, r*0.18, true);
      ellipse(hx + (v[0]?0:  r*0.22),  hy + (v[1]?0: r*0.18), r*0.18, r*0.18, true);
      ctx.fillStyle = '#333';
      ellipse(hx + (v[0]? r*0.1: -r*0.22), hy + (v[1]? r*0.1: -r*0.18), r*0.06, r*0.06, true);
      ellipse(hx + (v[0]? r*0.1:  r*0.22), hy + (v[1]? r*0.1:  r*0.18), r*0.06, r*0.06, true);
      ctx.fillStyle = '#ff6b6b'; const lx = hx + v[0]*r*0.7, ly = hy + v[1]*r*0.7;
      ellipse(lx, ly, r*0.12, r*0.2, true);
    }

    for(const p of particles){
      ctx.globalAlpha = Math.max(0, Math.min(1, p.life));
      const x = (p.x*u), y = (p.y*u);
      ctx.fillStyle = '#ffd166'; ellipse(x, y, u*0.12, u*0.12, true);
    }
    ctx.globalAlpha = 1;
    ctx.restore(); // board
    ctx.restore(); // shake
  }

  function rounded(x,y,w,h,r, fillStyle=null, fillStyle2=null){
    ctx.save();
    if(fillStyle) { ctx.fillStyle = fillStyle; }
    if(fillStyle2) { ctx.fillStyle = fillStyle2; }
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }
  function ellipse(x,y,rx,ry,fill){ ctx.beginPath(); ctx.ellipse(x,y,rx,ry,0,0,Math.PI*2); fill?ctx.fill():ctx.stroke(); }
  function gradient(ctx,x0,y0,w,h,stops){ const g = ctx.createLinearGradient(x0,y0,x0,y0+h); g.addColorStop(0,stops[0]); g.addColorStop(1,stops[1]); return g; }
  function cloud(x,y,s,op){ ctx.save(); ctx.globalAlpha = op; ctx.translate(x,y); ctx.scale(s,s); ctx.fillStyle='rgba(255,255,255,0.92)'; rounded(-60,-20,120,50,24); rounded(-30,-40,80,60,30); rounded(-90,-30,90,52,26); ctx.globalAlpha=1; ctx.restore(); }
  function rgb(arr){ return `rgb(${arr[0]},${arr[1]},${arr[2]})`; }
  function mixColor(a,b,t){ return [ Math.round(lerp(a[0],b[0],t)), Math.round(lerp(a[1],b[1],t)), Math.round(lerp(a[2],b[2],t)) ]; }

  function drawRibbon(pts, thickness, u){
    if(pts.length<2) return;
    const w = thickness;
    for(let i=pts.length-1;i>=0;i--){
      const p = pts[i];
      const fade = Math.max(0.25, 1 - i/ (pts.length*1.15));
      ctx.fillStyle = `rgba(0,0,0,${0.12*fade})`;
      ellipse(p.x*u+3, p.y*u+w*0.9, w*0.9, w*0.24, true);
      const gx = p.x*u, gy = p.y*u;
      const seg = ctx.createRadialGradient(gx-w*0.2,gy-w*0.2, w*0.2, gx,gy, w);
      seg.addColorStop(0,'#6cf08f'); seg.addColorStop(1,'#2ecc71');
      ctx.fillStyle = seg; ellipse(gx,gy, w, w*0.82, true);
    }
  }

  // ======= –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ =======
  function rotate(){
    if(!state.started){ state.started=true; hint.style.display='none'; }
    if(!state.alive){ reset(); state.started=true; hint.style.display='none'; }
    state.dir = turnCW(state.dir);
    beep('turn'); haptic(10);
  }
  function onPress(){ if(!actx){ try{ actx = new (window.AudioContext||window.webkitAudioContext)(); }catch(e){} } rotate(); }
  window.addEventListener('pointerdown', e=>{ e.preventDefault(); onPress(); }, {passive:false});
  tapBtn.addEventListener('pointerdown', e=>{ e.stopPropagation(); onPress(); });
  hint.addEventListener('pointerdown', e=>{ e.stopPropagation(); onPress(); });

  function setDir(d){
    if(!state.started){ state.started=true; hint.style.display='none'; }
    if(!state.alive){ reset(); state.started=true; hint.style.display='none'; }
    desiredDir = d; beep('turn'); haptic(8);
  }
  const dpadBind = (el,dir)=>{
    const handler = (e)=>{ e.preventDefault(); e.stopPropagation(); setDir(dir); };
    el.addEventListener('pointerdown', handler, {passive:false});
  };
  dpadBind(upBtn, DIR.U);
  dpadBind(downBtn, DIR.D);
  dpadBind(leftBtn, DIR.L);
  dpadBind(rightBtn, DIR.R);

  // Keyboard arrows support
  window.addEventListener('keydown', (e)=>{
    if(e.key==='ArrowUp') setDir(DIR.U);
    else if(e.key==='ArrowDown') setDir(DIR.D);
    else if(e.key==='ArrowLeft') setDir(DIR.L);
    else if(e.key==='ArrowRight') setDir(DIR.R);
    else if(e.key===' ') rotate();
  });

  pauseBtn.addEventListener('click',()=>{
    if(!state) return;
    if(state.started && state.alive){ state.started=false; toastMsg('–ü–∞—É–∑–∞'); }
    else { state.started=true; toastMsg('–ü–æ–µ—Ö–∞–ª–∏!'); }
  });
  restartBtn.addEventListener('click',()=>{ reset(); state.started=true; hint.style.display='none'; });

  // Haptics
  function haptic(ms){ if(navigator.vibrate) try{ navigator.vibrate(ms); }catch(_){} }

  function loop(ts){
    if(!lastTime) lastTime = ts;
    const maxDT = 1/cfg.maxFPS;
    const dt = Math.min((ts-lastTime)/1000, maxDT*2);
    lastTime = ts;
    update(dt); draw(ts);
    requestAnimationFrame(loop);
  }

  let toastTimer;
  function toastMsg(msg){
    toast.textContent = msg;
    toast.classList.add('show');
    clearTimeout(toastTimer);
    toastTimer = setTimeout(()=>toast.classList.remove('show'), 1200);
  }

  function resize(){ reset(); }
  window.addEventListener('resize', resize);
  window.addEventListener('orientationchange', resize);
  reset();
  requestAnimationFrame(loop);
  </script>
</body>
</html>
